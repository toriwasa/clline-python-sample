# Project Guidelines

## 技術スタック
- プログラミング言語: Python
- 単体テストフレームワーク: pytest
- DataFrame ライブラリ: Spark
- Linter: Ruff
- Formatter: Ruff
- Type Checker: pyright

## Linterの実行方法

```bash
uv run ruff check --fix
```

## Formatterの実行方法

```bash
uv run ruff format
```

## Type Checkerの実行方法
```bash
uv run pyright
```

## ディレクトリ構成

```txt
.
├ src
│  └ cline_sample
│      ├ domain
│      │    └ models  // ドメインモデルのデータクラスを定義
│      ├ infrastructure
│      │    ├ s3   // S3の読み書き処理を定義
│      │    └ db   // DBの読み書き処理を定義
│      ├ usecase  // ビジネスロジック処理を定義
│      ├ controller  // ビジネスロジック処理を呼び出すコントローラー処理を定義
│      └ handler
│           └ cui  // CUIで実行時のパラメータを受け取りコントローラー処理を呼び出す処理を定義
└ tests
  └ cline_sample
       └ usecase  // ビジネスロジック処理の単体テストコードを定義
```

## コード規約
- ファイル名は小文字のスネークケースで定義してください
- 関数名は動詞から始めてください
- 関数名は小文字のスネークケースで定義してください
- プロパティ関数名は名詞から始めてください
- クラス名はキャメルケースで定義してください
- 変数名は小文字のスネークケースで定義してください
- 定数名は大文字のスネークケースで定義してください
- コード内のリテラル値は定数としてファイルの先頭に定義してください
- 1つ以上のリテラル値だけを受け取る関数は引数の型にファイルの先頭に定義した Literal 型を指定してください
- 関数には関数コメントを記述してください
- 複雑な処理は、処理結果を説明する名前を持つ変数に代入して処理を分割してください
- import 文はファイルの先頭にまとめて記述してください
- import のパスは src からの相対パスで記述してください

## アーキテクチャ
- domain/models 層に定義されたデータクラスを利用してS3やDBのデータを読み書きする公開関数を infrastructure 層に定義してください
- infrastructure 層の読み込み公開関数は、S3やDBのレコードを models 層のデータクラスに変換して返却するだけで、ビジネスロジックを含んではいけません
- infrastructure 層の書き込み公開関数は、models 層のデータクラスをS3やDBのレコードに変換して書き込むだけで、ビジネスロジックを含んではいけません
- models 層のデータクラスを利用するビジネスロジック処理を usecase 層の公開関数に定義してください
- usecase 層の公開関数は関数型プログラミングの考え方に基づいて、副作用のない純粋関数になるように設計してください
- usecase 層の関数は引数と戻り値の型を明示的に指定してください
- infrastructure 層や usecase 層の公開関数を呼び出して処理の目的を達成するコントローラー層の公開関数を controller 層に定義してください
- CUIで実行時のパラメータを受け取りコントローラー層の公開関数を呼び出す公開関数を handler/cui 層の cui 層に定義してください

## infrastructure 層の関数設計方針
- infrastructure 層の公開関数は引数として Literal 型の env を受け取るようにしてください
- env は実行環境を表すリテラル値で "dev", "stg", "prod" のいずれかの値を持つようにしてください
- Literal 型はファイルの先頭に定義してください
- infrastructure 層では env を引数として実行環境に応じた S3接続先 や DBコネクション や SparkSession を返却する非公開関数を定義してください。match式を使って env の値に応じた処理を実装してください
- infrastructure 層の公開関数は、引数として env を受け取り、env に応じた非公開関数を呼び出して処理を実行してください

## ビジネスロジック関数の設計方針
- ビジネスロジック関数は、引数に models 層のデータクラスを受け取り、引数のデータクラスを変換して返却する関数を定義してください
- 引数のデータクラスにバリデーションチェックが必要な場合は、バリデーションチェックだけを行う関数を独立して定義してください
- バリデーションチェックが完了したデータクラスを引数として受け取るビジネスロジック関数を定義してください

## 関数の公開範囲ルール
- infrastructure 層と usecase 層で定義される関数のうち、コントローラー層から呼び出される関数は公開関数にしてください
- infrastructure 層と usecase 層で定義される関数のうち、コントローラー層から呼び出されない関数は非公開関数にしてください
- 非公開関数の名前は _（アンダースコア）から始めてください。 例: _private_function

## データクラスのコード規約
- データクラスは、ドメインモデルのデータクラスを定義する domain/models 層に定義してください
- DataFrame オブジェクトをデータとして持つクラスの場合は _df という名前の非公開属性を持つようにしてください
- DataFrame オブジェクトをデータとして持つクラスは、DataFrame のスキーマを検証するコンストラクタを持つようにしてください
- DataFrame オブジェクトをデータとして持つクラスは DataFrame を返すプロパティを持つようにしてください
- データクラスの属性を使って計算可能な値は、プロパティとして定義してください
- データクラスのクラスコメントには、データの説明と属性およびプロパティの説明を記述してください

```python
class User:
    def __init__(self, df: DataFrame):
        SCHEMA = StructType([
            StructField("id", StringType(), True),
            StructField("name", StringType(), True),
            StructField("age", IntegerType(), True),
        ])

        if df.schema != SCHEMA:
            raise ValueError(f"Invalid schema: EXPECTED: {SCHEMA} ACTUAL: {df.schema}")

        self._df = df

    @property
    def value(self) -> DataFrame:
        """ユーザーデータのDataFrame

        Fields:
            id(String): ユーザーID
            name(String): ユーザー名
            age(Integer): ユーザー年齢
        """
        return self._df
```

## 単体テスト作成方針
- テストコードは src/tests ディレクトリにプロダクトコードと同じディレクトリ構成で作成してください
- テストコードのファイル名は テスト対象のファイル名の先頭に test_ を付けてください
- テスト関数名は test_ から始めてください
- テスト関数名は処理内容ではなく検証したいビジネスルールを表現してください。例: test_不正なユーザー情報は集計されない
- 単体テストコードは Arrange, Act, Assert の 3 つのセクションに分けて記述してください
- Arrange セクションでは、テスト対象の関数に渡す引数や期待値を定義してください
- Arrange セクションで同一の意味の値を複数回使用する場合は、テスト関数内に定義した ConstantHelper クラス配下に定数として定義してください
- Act セクションでは、テスト対象の関数を呼び出して実行してください
- Assert セクションでは、Act セクションで実行した結果が期待値と一致するかを検証してください

## SparkDataFrameを引数に持つ公開関数のテストコード作成方針
- Arrange セクションでは createDataFrame メソッドを使って入力値および期待値の DataFrame を作成してください
- Arrange セクションで利用する createDataFrame メソッドは list[Row] 型のリストを引数として渡してください
- Assert セクションでは assertDataFrameEqual メソッドを使って、実行結果の DataFrame と期待値の DataFrame を比較してください
